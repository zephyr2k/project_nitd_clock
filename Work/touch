/***
TODO:                                       STATUS

    Implement basic function:
        insert_ready_ops                    WIP **
        schedule_op                         DONE
        delete                              DONE
        first                               DONE
    Implement List Scheduling               WIP
    Implement Schedule Structure            DONE, FEATURES TO BE ADDED
    Implement Plist                         DONE, FEATURES TO BE ADDED
    Graph Linking                           Done

** Requires reading schedule from Graph with ASAP , ALAP & Mobility of each vertex already computed.
BUGS
    1. Inadequate hw pushes other operation in that Control Step to below it - FIXED (It ignores the new schedule operation)

***/

#include<iostream>
#include<malloc.h>
#include<vector>
#include<string>

#define MAX_LT 100

using namespace std;
typedef struct PList
{
    char op;
    PList *next; //Schedule Structure
    PList *fwd; // Original Graph Sequence
    int mobility;
    int vertex_no;
    int cStep;
    PList(char init_op)
    {
        op=init_op;
        next=NULL;
        mobility=0;
        vertex_no=0;
        cStep=-1;
    }
    int toString()
    {
        cout<<" "<<vertex_no<<"<"<<mobility<<"> ";
        return 1;
    }
};
typedef struct PListHead
{
    PList *head;

    PListHead()
    {
       // op_type=ot;
        head=NULL;
    }

};
typedef struct PListMain
{
    int M; //No of Operation
    char op_type[MAX_LT];
    PListHead *direct[MAX_LT];
    PListMain(string ops)
    {
        M=ops.length();
        for(int i=0;i<M;i++)
        {
             direct[i]=(PListHead*) malloc(ops.length() * sizeof(PListHead));
             //direct[i]->op_type=ops[i];
             op_type[i]=ops[i];
        }
    }
};
typedef struct Schedule
{
    int n_cSteps;
    int n_ops;
    PList *pOps[MAX_LT];// 100 - max no of operations
    string op_arrange;
    Schedule(int n_cS,string op)
    {
        //op - String for hardware constraints like adder
        /***
        n_cS - no of control steps
        n_o - no of operators (5 for below)
        Usage : For 2 multiplication, 1 adder, 1 subtractor, 1 comparator
        op should be : **+-> (in any order)
        ***/
        n_cSteps=n_cS;
        n_ops=op.length();
        op_arrange=op;

        for(int i=0;i<n_ops;i++)
        {
        	pOps[i]=new PList(op[i]);
        	//pOps[i]->next=NULL;
        }
    }
    int toString()
    {
        cout<<"cSteps: "<<n_cSteps<<"\t nOps: "<<n_ops<<"\n";
            for(int j=0;j<n_ops;j++)
            {
                cout<<""<<op_arrange[j]<<"\t";
                PList *temp=pOps[j];
                while(temp!=NULL)
                {
                    if(temp->cStep!=-1)
                    {
                    temp->toString();
                    cout<<" "<<temp->cStep;
                    cout<<" -->  ";
                    }
                    temp=temp->next;

                }
                 cout<<"\n";
            }
        return 1;
    }
};
typedef struct AdjListNode
{
    int dest;
    AdjListNode* next;
};

// A structure to represent an adjacency liat
typedef struct AdjList
{
    AdjListNode *head;  // pointer to head node of list
};

// A structure to represent a graph. A graph is an array of adjacency lists.
// Size of array will be V (number of vertices in graph)
typedef struct Graph
{
    int V;
    AdjList* su;
    AdjList* pre;
    int mob[MAX_LT];
    char operation[MAX_LT];
    int stat[MAX_LT];
};
// A utility function to create a new adjacency list node
AdjListNode* newAdjListNode(int dest)
{
    AdjListNode* newNode =
            (AdjListNode*) malloc(sizeof(AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}
///  Global Variable Declaration HERE
///
///
///




// A utility function that creates a graph of V vertices
Graph* createGraph(int V)
{
    Graph* graph = (Graph*) malloc(sizeof(Graph));
    graph->V = V;

    // Create an array of adjacency lists.  Size of array will be V
    graph->su = (AdjList*) malloc(V * sizeof(AdjList));
    graph->pre = (AdjList*) malloc(V * sizeof(AdjList));

     // Initialize each adjacency list as empty by making head as NULL

    for (int i = 0; i < V; ++i){
        graph->operation[i]='E';
        graph->su[i].head = NULL;
        graph->pre[i].head = NULL;
        graph->mob[i]=-1;
        graph->stat[i]=1;
        }
    return graph;
}
void addEdge(Graph* graph, int src, int dest)
{
    // Add an edge from src to dest.  A new node is added to the adjacency
    // list of src.  The node is added at the begining
    AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->su[src].head;
    graph->su[src].head = newNode;

    // Since graph is undirected, add an edge from dest to src also
    newNode = newAdjListNode(src);
    newNode->next = graph->pre[dest].head;
    graph->pre[dest].head = newNode;
}

/*** Allocates mobility to vertices after computation ***/
int alloc_op_mbty(Graph* graph,char *op,int *arr)
{
    cout<<"\n";
    //cout<<op<<"\n";
    for(int v=0;v<graph->V;++v)
    {

        graph->mob[v]=arr[v];
        graph->operation[v]=op[v];
       // cout<<v<<" : "<<graph->mobility[v]<<"\n";
    }
    return 1;
}

int checkConflicts(PList *p,PList *k,int Cstep)
{
    while(p!=NULL)
    {
        if(p->cStep>0 && p->cStep==Cstep)
            return 0;
        p=p->next;
    }
return 1;
}
// STUPID code needs rethinking
PList* first(PList *p)
{
    if(p==NULL)
        return NULL;
    return p;
}
PList* delete_(PList *p,PList *del)
{
    if(p->vertex_no==del->vertex_no)
        return p->next;
    PList *temp=p;
    while(temp!=NULL)
    {
        if(temp->vertex_no==del->vertex_no)
        {
                /***   VERIFICATION NEEDED IF IT DELETES PROPERLY LAST NODE OF LINKED LIST  ***/
                PList *t=temp->next;
                temp->next=NULL;
                temp=t;
        }
        temp=temp->next;
    }
    return p;
}
PList* insert_PList(PList *p,PList *k,int x)
{
    int t=0;
    if(p->cStep==-1)
    {
        p=k;t=1;
    }
    else if(p->next==NULL)
    {
        if(k->cStep>p->cStep)
        {
            p->next=k;
        }
        else
        {
            k->next=p;
            p=k;
        }
        t=1;
    }
        PList *prev=p;
        PList *curr=p->next;
        /*** Code to insert a node by comparing cStep***/
        while(curr!=NULL)
        {
            if(curr->cStep>x)// IMP
            {
                prev->next=k;
                k->next=curr;
                break;
            }
            prev=curr;
            curr=curr->next;

        }
    if(t==0)
    {
        prev->next=k;
    }
    k->cStep=x;
    return p;
}
Schedule* schedule_op(Schedule *S,PList *tk,int Cstep)
{
        int loc=-1;
        for(int i=0;i<S->op_arrange.length();i++)
        {
            if(S->op_arrange[i]==tk->op && checkConflicts(S->pOps[i],tk,Cstep))
                {
                loc=i;
                break;
                }
        }
        //cout<<loc<<"\n";
        if(loc>=0)
        {
            S->pOps[loc]=insert_PList(S->pOps[loc],tk,Cstep);
        }
    return S;
}
Graph* delete_Pred(Graph* graph,int V)
{
    for(int v=0;v<graph->V;v++)
    {

    }
}
Graph* delete_Succ(Graph *graph,int fromDel,int toDel)
{
    AdjListNode *curr=graph->pre[fromDel].head;
    AdjListNode *prev=curr;
    //printf("\nFrom %d delete %d\n",curr->dest,toDel);
    if(curr==NULL)
        {
        curr=NULL;
       // cout<<"1.\n";
        }
    else if(curr->dest==toDel)
        {
        /// Not Working
        /// FIXED
        graph->pre[fromDel].head=graph->pre[fromDel].head->next;
       // cout<<"2.\n";
       printf("Delete from %d to %d\n",fromDel,toDel);
        }
    else
    {
    prev=curr;
    curr=curr->next;
    //cout<<"3.\t";
    while(curr!=NULL)
    {
       // cout<<curr->dest<<"\n";

        if(curr->dest==toDel)
        {
        printf("Delete from %d to %d\n",fromDel,toDel);
        //Deleting starts

            //AdjListNode *t=temp->next;
            //temp->next=NULL;
            //temp=t;
            prev->next=curr->next;
            curr->next=NULL;
            break;
        }

        prev=curr;
        curr=curr->next;
    }
    }
return graph;
}
int checkPred(Graph *graph,int v)
{
    //return true for empty predecessors
     AdjListNode* p = graph->pre[v].head;
     if(p==NULL)
        return 1;
    else
        return 0;
}

int insert_ready_ops(Graph *graph,int m)
{
    /***
    Scans all nodes, check for predecessors ,
    If empty deletes V ,and appends to Plist based on operation type
    ***/
    vector<int> visited(graph->V,0);
    for(int v=0;v<graph->V;v++)
    {
        //checks for NULL ref
        // check if adjNodes are there or not
        if(checkPred(graph,v) && visited[v]!=1)
        {

            PList *t=new PList(graph->operation[v]);
            t->vertex_no=v;
            t->mobility=graph->mob[v];
            // current node to be deleted
            //goto successor of v delete all ref to v
            AdjListNode *p=graph->su[v].head;
            while(p!=NULL)
            {
                //cout<<p->dest<<"\t"<<v<<"\n";
                delete_Succ(graph,p->dest,v);
                visited[p->dest]=1;
                p=p->next;
            }
            //del all ref of curr
             graph->su[v].head=NULL;
             graph->stat[v]=0;
             /***
                Above removal from list successfull .
                Below adding the removed nodes to PList
            ***/

        char type=graph->operation[v];
        for(int i=0;i<m;i++)
        {
            if(PListMain->op_type==type)
            {
                // type match found int PList
                PListHead *temp=new PListHead();
                
            }
        }
        }

    }
}

// A utility function to print the adjacency list representation of graph
void printGraph(Graph* graph,int i=0)
{
    int v;
    cout<< "\n\n-------------Graph Printing----------------\n";
if(i==0)
    {
    for (v = 0; v < graph->V; ++v)
    {
        if(graph->stat[v]!=0)
        cout<<v<<": "<< graph->mob[v] <<" "<<graph->operation[v]<<"\n";
    }
    }
else
    {
    for (v = 0; v < graph->V; ++v)
    {
         if(graph->stat[v]!=0)
         {
        AdjListNode* pCrawl = graph->su[v].head;
        printf("\n Adjacency list of vertex %d: head ", v);
        while (pCrawl)
        {
            printf("-> %d", pCrawl->dest);
            pCrawl = pCrawl->next;
        }
        }

    }
    printf("\n");
    printf("..........");
    printf("\n");
    for (v = 0; v < graph->V; ++v)
    {
        if(graph->stat[v]!=0)
         {
        AdjListNode* pCrawl = graph->pre[v].head;
        printf("\n Predecesor list of vertex %d : head ", v);

        while (pCrawl)
        {
            printf("-> %d", pCrawl->dest);
            pCrawl = pCrawl->next;

        }
        }
        //printf("\n");
    }
    }
    cout<< "\n-------------Graph Printing---------------\n\n";
}
int main()
{
    cout<<"\n";
    string op_arr="";
    /*** Example from notes
        V=11
        E=11
    ***/
    int V=11;
    Graph* graph = createGraph(V);
    addEdge(graph, 0, 4);
    addEdge(graph, 1, 4);
    addEdge(graph, 4, 6);
    addEdge(graph, 6, 7);
    addEdge(graph, 5, 7);
    addEdge(graph, 2, 5);
    addEdge(graph, 3, 8);
    addEdge(graph, 9, 10);
    int arr[]={0,0,1,2,0,1,0,0,2,2,2};
    char ops[]="******--++<";
    //printGraph(graph,0);
    alloc_op_mbty(graph,ops,arr);
    //cout<<graph->mbty[0]<<"\n";

    printGraph(graph,1);

    cout<<"\nChange\n\n";
    insert_ready_ops(graph,1);
    printGraph(graph,1);
    insert_ready_ops(graph,1);
    printGraph(graph,1);
    //cout<<checkPred(graph,6);

    //alloc_operation(graph,ops);
   // printGraph(graph,0);
    //cout<<graph->mbty[0]<<"\n";
    /*cout<<"\n";
    op_arr="*<+*-";
    PList *p1=new PList('-');
    p1->vertex_no=1;
    p1->mobility=2;
    PList *p2=new PList('*');
    p2->vertex_no=2;
    p2->mobility=3;
    PList *p3=new PList('*');
    p3->vertex_no=3;
    p3->mobility=4;
    PList *p4=new PList('*');
    p4->vertex_no=4;
    p4->mobility=5;
    Schedule *currS=new Schedule(4,op_arr);

    cout<<"Before scheduling :\n";
    currS->toString();
    currS=schedule_op(currS,p1,1);
    currS=schedule_op(currS,p2,1);
    currS=schedule_op(currS,p3,1);
    currS=schedule_op(currS,p4,1);
    cout<<"After scheduling :\n";
    currS->toString();
*/
    cout<<"\n";
return 0;
}

